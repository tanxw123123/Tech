## 1.基础知识

https://edu.51cto.com/courselist/298.html?cate_id=298

https://edu.51cto.com/course/22985.html   wireshark抓包学习

**协议分析**

- ICMP、IP、ARP、TCP

- 应用层协议：SSH、FTP、DNS、HTTP、HTTPS

**数据的封装与解封装：**

数据-应用层

TCP头部-传输层

IP头部-网络层

mac头部-数据链路层



**TTL生存时间**：数据包允许被路由转发的最大次数，防止数据包在路由间无限转发

默认linux发出的数据包TTL为：64

默认windows发出的数据包TTL为：128



**路由追踪**：检测数据包具体经过了哪些路由

- tracert：windows

- traceroute： linux

​        Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。



**ICMP控制消息类型**： wireshark抓包可以查看具体详情

- 类型0：回显应答

- 类型3：目标不可达

- 类型4：源抑制

- 类型8：回显请求

- 类型11：超时

**默认路由**

```shell
$ route -n
$ route add default gw 192.168.254.254   #添加默认路由
$ route del -net 0.0.0.0  #删除默认路由
```



**ARP协议工作过程 **

![image-20221031104943960](D:\Tech\linux\Ronnie\.assets\image-20221031104943960.png)

**A主机和B主机在同一网段：**

默认，当A发送数据给B，在A的arp缓存表是空的，没有B主机的ip和mac对应关系。所以A主机这里数据封装（数据链路层）就只能暂停下来； 首先执行ARP request

```shell
ARP request
# 数据 
目的ip：192.168.1.101
源  ip：192.168.1.100
目的mac：00:00:00:00:00:00
源  mac：A的MAC

# 封装数据帧
目的MAC：FF:FF:FF:FF:FF:FF    # arp广播
源  MAC：A的MAC
------------------------
ARP response
# 数据 
目的ip：192.168.1.100
源  ip：192.168.1.101
目的mac：A的MAC
源  mac：B的MAC

# 封装数据帧
目的MAC：A的MAC    # 单播
源  MAC：B的MAC
```

**A主机和C主机在不同网段：**

这种情况和第一种情况就不同了。A发送数据给C主机，数据需要层层封装，第一层数据封装如下：

```shell
源  ip：192.168.1.100
目的ip：192.168.2.100
源  MAC：A的MAC
目的MAC：网关192.168.1.1的MAC   # 注意这里不是C主机的mac

当网关接收到数据，再将源MAC置为网关的MAC，目的MAC为下一跳路由的MAC。
```

---

```shell

$ arp -ne    #linux查看arp缓存表
$ arp -d 192.168.1.x    # 删除arp缓存表记录

> arp -a     #windows查看arp缓存表  #主要看动态
> arp -d 192.168.1.x    # windows需要以管理源身份运行执行cmd
```

ARP欺骗：

```
ARP断网攻击

中间人攻击
arp数据包无法被路由器转发
```



nmap主机发现

```shell
$ nmap -sn -n 192.168.254.0/24 -oG -     # -oG -   显示更直观  
# -n    不做dns反向解析，节约时间
这种主机发现实际上是通过发送arp的广播探测，而不是ping；如果用ping做主机发现，那么如果对方禁ping，将无法拿到准确的结果。

nmap 半开式扫描，默认
$ nmap -sS -p21,22,80 192.168.254.70    # 对主机的21，22，80做半开始扫描
$ nmap -p21,22,80 192.168.254.70  # 同上，-sS属于默认，可以省略
$ nmap -p- 192.168.254.70    #全端口扫描，也可以用  -p1-65535
$ nmap -sV 192.168.254.70   # 扫描常用1000个端口

# 半开式扫描只会经过tcp两次握手，第三次，客户端会向服务端返回RST标志位，重置连接。在目标机器不会留下痕迹，比较隐蔽。

- nmap主机发现过程分析：
如果向目标主机发送未经请求的ACK报文，那么目标主机将返回RST报文。
什么叫未经请求的ACK报文呢？
   正常tcp请求都是从syn请求报文开始的，而这里没有第一步syn请求，直接发ACK报文。目标收到请求不明白什么意思，会直接返回RST重置。只要目标有返回则代表在线，从而判断主机在线。
-sn选项：
扫描同一个网段：发送ARP请求
扫描不同网段： 发送icmp以及syn/ack请求

-PS，发送syn报文
-PA，发送ACK报文



```



**tcp协议与socket**

socket：ip+端口（识别不同主机的不同程序）

tcp连接实际上是两个socket的连接。 

http属于单向连接，短连接

**DOS攻击**

```shell
死亡之ping： ping ip地址 -l 65500 -t


hping3:  hping -S --flood -p 80 192.168.254.70
---
syn flood攻击：
$ hping3 -S -p 80 --flood --rand-source 192.168.254.70  # -S选项为发送syn攻击

icmp flood攻击：
$ hping3 --icmp --flood --rand-source 192.168.254.70

UDP flood攻击：
$ hping3 -udp -p 53 --flood --rand-source 192.168.254.70

```



**TCP协议原理**

```
- 面向连接：三次握手
- 可靠的：重传机制
- 基于字节流： TCP会给传输的每个字节做一个编号（32为进制数），将这些字节看作数据流，拆分成一个个数据段。拆分后的数据段也要有一个序号（seq）。

序号和确认号：
- 序号，发送方所要发送的数据段的编号
比如，序号是1，这个数据段要发送的数据长度是1000字节。
当接收方收到这个数据段之后，返回的确认号应该是1001.
- 确认号，即表示之前的字节已经收到，又告诉对方接下来从哪个字节开始发送。

抓包验证：序号和确认号
```

标志位和窗口：

```
标志位置为1表示启用
RST：重置标志位，

窗口：限制对方发给我们的数据包的大小。 滑动窗口（流量控制），窗口大小不是固定的。
```

追踪流，流索引；抓包分析。



tcp超时重传机制：

```
超时重传
TCP 为了实现可靠传输，实现了重传机制。最基本的重传机制，就是超时重传，即在发送数据报文时，设定一个定时器，每间隔一段时间，没有收到对方的ACK确认应答报文，就会重发该报文。
这个间隔时间，一般设置为多少呢？我们先来看下什么叫RTT（Round-Trip Time，往返时间）。

RTT就是，一个数据包从发出去到回来的时间，即数据包的一次往返时间。超时重传时间，就是Retransmission Timeout ，简称RTO。

RTO设置多久呢？

如果RTO比较小，那很可能数据都没有丢失，就重发了，这会导致网络阻塞，会导致更多的超时出现。
如果RTO比较大，等到花儿都谢了还是没有重发，那效果就不好了。
一般情况下，RTO略大于RTT，效果是最好的。
```

滑动窗口：

https://juejin.cn/post/6983639186146328607

## 2.**wireshark**

​        Ethereal和在Windows系统中常用的sniffer pro并称网络嗅探工具双雄，不过和sniffer pro不同的是Ethereal在Linux类系统中应用更为广泛

​        而Wireshark软件则是Ethereal的后续版本，他是在Ethereal被 收购后推出的最新网络嗅探软件，在功能上比前身更加强大.

过滤器：

```shell
- 捕捉过滤器：用于决定将什么样的信息记录在捕捉结果中。需要在开始捕捉前设置。
- 显示过滤器：在捕捉结果中进行详细查找。他们可以在得到捕捉结果后随意修改
```

两种过滤器的目的是不同的：

```shell
- 捕捉过滤器: 是数据经过的第一层过滤器，它用于控制捕捉数据的数量，以避免产生过大的日志文件。
- 显示过滤器: 是一种更为强大（复杂）的过滤器。它允许您在日志文件中迅速准确地找到所需要的记录。
```

抓包模式：

```shell
- 混杂模式（默认）
- 普通模式： 只接受发送给本机的包

修改混杂模式：  捕获-选项
```

过滤器使用：

```
过滤ip： 过滤框输入： ip.addr == x.x.x.x
过滤tcp：    tcp
过滤dns：  dns

ip.src_host == 192.168.254.11 or/and ip.dst_host == 192.168.254.254
```

mtr工具

流量分析

主要功能和使用技巧

CTF例题分析

## 3.tcpdump抓包

https://juejin.cn/post/6844904084168769549

```
如果要使用tcpdump抓取其他主机MAC地址的数据包，必须开启网卡混杂模式，所谓混杂模式，用最简单的语言就是让网卡抓取任何经过它的数据包，不管这个数据包是不是发给它或者是它发出的。一般而言，Unix不会让普通用户设置混杂模式，因为这样可以看到别人的信息，比如telnet的用户名和密码，这样会引起一些安全上的问题，所以只有root用户可以开启混杂模式，开启混杂模式的命令是：ifconfig en0 promisc, en0是你要打开混杂模式的网卡。
```

